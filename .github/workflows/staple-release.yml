name: Staple and Publish Release

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag (optional - auto-detects latest draft if not provided)'
        required: false
        type: string

permissions:
  contents: write  # Required to update release assets and notes

jobs:
  staple:
    name: Staple Notarization and Update Release
    runs-on: macos-14

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect or use provided release tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PROVIDED_TAG="${{ github.event.inputs.release_tag }}"

          if [[ -n "$PROVIDED_TAG" ]]; then
            # Use provided tag
            TAG="$PROVIDED_TAG"
            echo "üìå Using provided release tag: $TAG"
          else
            # Auto-detect latest release (draft or published)
            echo "üîç Auto-detecting latest release..."

            # First try to find a draft release
            LATEST_DRAFT=$(gh release list --draft --limit 1 --json tagName --jq '.[0].tagName // empty')

            if [[ -n "$LATEST_DRAFT" ]]; then
              TAG="$LATEST_DRAFT"
              echo "üìå Auto-detected draft release: $TAG"
            else
              # No drafts found, try latest published release
              echo "‚ö†Ô∏è  No draft releases found, checking latest published release..."
              LATEST_RELEASE=$(gh release list --limit 1 --json tagName --jq '.[0].tagName // empty')

              if [[ -z "$LATEST_RELEASE" ]]; then
                echo "::error::No releases found (draft or published). Please provide a release tag manually."
                exit 1
              fi

              TAG="$LATEST_RELEASE"
              echo "üìå Auto-detected published release: $TAG"
              echo "::warning::Release is already published. Will staple and update in place."
            fi
          fi

          VERSION=${TAG#v}  # Remove 'v' prefix
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "TAG=$TAG" >> $GITHUB_ENV

      - name: Get release info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìã Fetching release information for $TAG..."

          # Get release ID and body
          gh release view "$TAG" --json id,body > release-info.json

          RELEASE_ID=$(jq -r '.id' release-info.json)
          RELEASE_BODY=$(jq -r '.body' release-info.json)

          # Extract notarization submission ID from release notes
          NOTARIZATION_ID=$(echo "$RELEASE_BODY" | grep -oE 'Submission ID: `[^`]+`' | sed 's/Submission ID: `\(.*\)`/\1/' || echo "")

          if [[ -z "$NOTARIZATION_ID" ]]; then
            echo "::error::Could not find notarization submission ID in release notes"
            echo "Please ensure this release was created by the release workflow"
            exit 1
          fi

          echo "RELEASE_ID=$RELEASE_ID" >> $GITHUB_ENV
          echo "NOTARIZATION_ID=$NOTARIZATION_ID" >> $GITHUB_ENV

          echo "‚úÖ Found release"
          echo "   Release ID: $RELEASE_ID"
          echo "   Notarization ID: $NOTARIZATION_ID"

      - name: Verify notarization status (with polling)
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "üîç Checking notarization status..."

          MAX_ATTEMPTS=120  # 120 attempts = up to 60 minutes with 30s delays
          ATTEMPT=1
          WAIT_TIME=30     # Start with 30 second wait between checks

          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "üìã Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking notarization status..."

            # Get notarization info
            xcrun notarytool info "$NOTARIZATION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --output-format json > notarization-info.json

            STATUS=$(jq -r '.status' notarization-info.json)
            echo "   Status: $STATUS"

            if [[ "$STATUS" == "Accepted" ]]; then
              echo ""
              echo "‚úÖ Notarization accepted by Apple!"
              exit 0
            elif [[ "$STATUS" == "Invalid" ]]; then
              echo "::error::Notarization was rejected by Apple"
              echo ""
              echo "Getting detailed rejection log..."
              xcrun notarytool log "$NOTARIZATION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" \
                developer_log.json || true
              if [[ -f developer_log.json ]]; then
                echo ""
                echo "Rejection details:"
                cat developer_log.json
              fi
              exit 1
            elif [[ "$STATUS" == "In Progress" ]]; then
              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "   ‚è≥ Still processing... waiting ${WAIT_TIME}s before next check"
                sleep $WAIT_TIME
                ATTEMPT=$((ATTEMPT + 1))
              else
                echo "::error::Notarization timeout - exceeded maximum wait time (60 minutes)"
                echo ""
                echo "The notarization is still in progress. This may indicate:"
                echo "  - Apple's servers are experiencing delays"
                echo "  - There's an issue with the notarization submission"
                echo ""
                echo "You can check the status manually at any time by running:"
                echo "  xcrun notarytool info $NOTARIZATION_ID --apple-id <email> --password <app-password> --team-id <team-id>"
                exit 1
              fi
            else
              echo "::error::Unknown notarization status: $STATUS"
              exit 1
            fi
          done

      - name: Download and verify DMG from release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üì• Downloading DMG and checksum from release..."

          # Download the DMG and checksum
          gh release download "$TAG" \
            --pattern "MacDown-${VERSION}.dmg*" \
            --dir build

          echo "‚úÖ DMG and checksum downloaded"
          ls -lh build/

          # Verify checksum
          echo "üîç Verifying DMG integrity..."
          cd build
          shasum -a 256 -c "MacDown-${VERSION}.dmg.sha256"
          cd ..

          # Verify DMG signature
          echo "üîç Verifying DMG signature..."
          codesign -vvv --strict "build/MacDown-${VERSION}.dmg"

          # Verify it's signed with Developer ID
          SIGNING_IDENTITY=$(codesign -dvv "build/MacDown-${VERSION}.dmg" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$SIGNING_IDENTITY" ]]; then
            echo "::error::Downloaded DMG is not properly signed"
            exit 1
          fi

          echo "‚úÖ DMG verified and ready for stapling"

      - name: Staple notarization ticket
        run: |
          echo "üìé Stapling notarization ticket to DMG..."

          # Staple the ticket
          xcrun stapler staple "build/MacDown-${VERSION}.dmg"

          # Validate stapling
          echo "üîç Validating stapled ticket..."
          xcrun stapler validate "build/MacDown-${VERSION}.dmg"

          # Re-verify code signature after stapling
          echo "üîç Verifying code signature is intact after stapling..."
          codesign -vvv --strict "build/MacDown-${VERSION}.dmg"

          # Verify with spctl
          echo "üîç Verifying Gatekeeper acceptance..."
          spctl -a -vvv -t install "build/MacDown-${VERSION}.dmg"

          echo "‚úÖ DMG successfully stapled and verified"

      - name: Generate updated checksums
        run: |
          echo "üîê Generating checksums for stapled DMG..."

          cd build
          shasum -a 256 "MacDown-${VERSION}.dmg" > "MacDown-${VERSION}.dmg.sha256"

          echo "Checksum:"
          cat "MacDown-${VERSION}.dmg.sha256"

          # Save for release notes
          CHECKSUM=$(cat "MacDown-${VERSION}.dmg.sha256")
          echo "CHECKSUM=$CHECKSUM" >> $GITHUB_ENV

          echo "‚úÖ Checksums generated"

      - name: Final comprehensive verification
        run: |
          echo "üîç Running final comprehensive verification before publishing..."

          DMG_PATH="build/MacDown-${VERSION}.dmg"

          # 1. Verify DMG signature
          echo "  ‚úì Checking DMG signature..."
          codesign -vvv --strict "$DMG_PATH"

          # 2. Verify notarization staple
          echo "  ‚úì Checking notarization staple..."
          xcrun stapler validate "$DMG_PATH"

          # 3. Verify Gatekeeper acceptance
          echo "  ‚úì Checking Gatekeeper acceptance..."
          spctl -a -vvv -t install "$DMG_PATH"

          # 4. Mount and verify app inside DMG
          echo "  ‚úì Checking app bundle inside DMG..."
          hdiutil attach "$DMG_PATH" -mountpoint /tmp/final-verify -nobrowse -readonly
          codesign -vvv --deep --strict "/tmp/final-verify/MacDown 3000.app"

          # Get app version for logging
          APP_VERSION=$(/usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" \
                        "/tmp/final-verify/MacDown 3000.app/Contents/Info.plist" 2>/dev/null || echo "unknown")
          echo "    App version: $APP_VERSION"

          hdiutil detach /tmp/final-verify

          # 5. Verify checksum matches
          echo "  ‚úì Verifying checksum..."
          cd build
          shasum -a 256 -c "MacDown-${VERSION}.dmg.sha256"
          cd ..

          echo ""
          echo "‚úÖ All verification checks passed!"
          echo "üéâ DMG is ready for distribution"
          echo ""

      - name: Update release with stapled DMG
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üì§ Updating release with stapled DMG..."

          # Upload stapled DMG and new checksum
          # --clobber replaces existing assets atomically (no race condition)
          gh release upload "$TAG" \
            "build/MacDown-${VERSION}.dmg" \
            "build/MacDown-${VERSION}.dmg.sha256" \
            --clobber

          echo "‚úÖ Release updated with stapled DMG (assets replaced atomically)"

      - name: Update release notes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "üìù Updating release notes..."

          # Verify changelog entry exists
          if ! grep -q "^## \[${VERSION}\]" CHANGELOG.md; then
            echo "::error::No changelog entry found for version ${VERSION}"
            echo "::error::Please add a changelog entry to CHANGELOG.md"
            exit 1
          fi

          # Extract changelog for this version
          echo "Extracting changelog for version ${VERSION}..."

          # Use awk with string matching (not regex) to extract the section
          CHANGELOG_CONTENT=$(awk -v ver="${VERSION}" '
            /^## \[/ {
              if (found) exit
              if (index($0, "[" ver "]") > 0) {
                found=1
                next
              }
            }
            found && /^## / { exit }
            found && !/^---$/ { print }
          ' CHANGELOG.md)

          if [ -z "$CHANGELOG_CONTENT" ]; then
            echo "::error::Failed to extract changelog content for version ${VERSION}"
            exit 1
          fi

          echo "‚úÖ Extracted changelog for version ${VERSION}"

          # Create release notes with changelog + verification details
          cat > release-notes.md <<EOF
          **MacDown 3000** is a modern, open-source Markdown editor for macOS.

          ${CHANGELOG_CONTENT}

          ## Verification

          ‚úÖ This build is **fully notarized and stapled** by Apple.

          **SHA256 Checksum:**
          \`\`\`
          ${CHECKSUM}
          \`\`\`

          Verify after download:
          \`\`\`bash
          shasum -a 256 MacDown-${VERSION}.dmg
          \`\`\`

          ---

          **Full Changelog:** https://github.com/${GITHUB_REPOSITORY}/blob/main/CHANGELOG.md
          EOF

          # Update the release notes
          gh release edit "$TAG" --notes-file release-notes.md

          echo "‚úÖ Release notes updated"

      - name: Publish release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üöÄ Publishing release..."

          # Check if release is already published
          IS_DRAFT=$(gh release view "$TAG" --json isDraft --jq '.isDraft')

          if [[ "$IS_DRAFT" == "true" ]]; then
            echo "Release is draft, publishing now..."
            gh release edit "$TAG" --draft=false
            echo ""
            echo "‚úÖ Release published successfully!"
          else
            echo "Release is already published, skipping publish step."
            echo ""
            echo "‚úÖ Release updated successfully!"
          fi

          echo "üéâ View at: https://github.com/${{ github.repository }}/releases/tag/$TAG"
          echo ""
          echo "The update-website workflow will now run automatically."
