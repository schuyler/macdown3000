name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0)'
        required: true

permissions:
  contents: write  # Required to create releases and upload assets

jobs:
  release:
    name: Build, Sign, Notarize, and Release
    runs-on: macos-14

    steps:
      # ==================== SETUP ====================

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0  # Need full history to check branch

      - name: Verify tag is on main branch
        if: github.ref_type == 'tag'
        run: |
          echo "ðŸ” Verifying that tag ${{ github.ref_name }} is on main branch..."

          # Get the commit hash of the tag
          TAG_COMMIT=$(git rev-parse ${{ github.ref_name }})

          # Check if this commit is reachable from main
          if git merge-base --is-ancestor "$TAG_COMMIT" origin/main 2>/dev/null; then
            echo "âœ… Tag is on main branch (or ancestor of main)"
          else
            echo "::error::Tag ${{ github.ref_name }} is NOT on the main branch!"
            echo "::error::Release tags must be created from the main branch only."
            echo "::error::Please delete this tag and create it from main:"
            echo "::error::  git push origin :refs/tags/${{ github.ref_name }}"
            echo "::error::  git tag -d ${{ github.ref_name }}"
            echo "::error::  git checkout main"
            echo "::error::  git pull origin main"
            echo "::error::  git tag ${{ github.ref_name }}"
            echo "::error::  git push origin ${{ github.ref_name }}"
            exit 1
          fi

      - name: Validate required secrets
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
        run: |
          MISSING_SECRETS=()

          if [[ -z "$APPLE_TEAM_ID" ]]; then
            MISSING_SECRETS+=("APPLE_TEAM_ID")
          fi
          if [[ -z "$APPLE_CERTIFICATE_BASE64" ]]; then
            MISSING_SECRETS+=("APPLE_CERTIFICATE_BASE64")
          fi
          if [[ -z "$APPLE_CERTIFICATE_PASSWORD" ]]; then
            MISSING_SECRETS+=("APPLE_CERTIFICATE_PASSWORD")
          fi
          if [[ -z "$APPLE_ID" ]]; then
            MISSING_SECRETS+=("APPLE_ID")
          fi
          if [[ -z "$APPLE_APP_PASSWORD" ]]; then
            MISSING_SECRETS+=("APPLE_APP_PASSWORD")
          fi

          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo "::error::Missing required GitHub secrets: ${MISSING_SECRETS[*]}"
            echo ""
            echo "Please configure the following secrets in your GitHub repository settings:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "  - $secret"
            done
            echo ""
            echo "See plans/release-process.md for setup instructions."
            exit 1
          fi

          echo "âœ… All required secrets are configured"

      - name: Extract version from tag or input
        run: |
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
            VERSION=${VERSION#v}  # Remove 'v' prefix if present
          else
            VERSION="${{ github.event.inputs.version }}"
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "ðŸ“¦ Building version: $VERSION"

      - name: Detect pre-release from version string
        run: |
          if [[ "$VERSION" =~ -(beta|alpha|rc) ]]; then
            echo "PRERELEASE=true" >> $GITHUB_ENV
            echo "ðŸ§ª Detected pre-release version"
          else
            echo "PRERELEASE=false" >> $GITHUB_ENV
            echo "ðŸš€ Detected production release version"
          fi

      - name: Set build timestamp
        run: echo "BUILD_TIME=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV

      # ==================== DEPENDENCIES ====================

      - name: Setup MacDown build environment
        uses: ./.github/actions/setup-macdown

      - name: Install build tools
        run: brew install create-dmg jq

      # ==================== CODE SIGNING SETUP ====================

      - name: Setup code signing keychain
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          echo "ðŸ” Setting up code signing keychain..."

          # Generate random password for temporary keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

          # Import Developer ID certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > certificate.p12

          # Use trap to ensure certificate cleanup even on error
          trap 'rm -f certificate.p12' EXIT

          security import certificate.p12 \
            -k build.keychain \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign

          # Prevent codesign from prompting for keychain password
          security set-key-partition-list \
            -S apple-tool:,apple: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            build.keychain

          # Verify certificate is available
          echo "ðŸ“‹ Available code signing identities:"
          security find-identity -v -p codesigning

      - name: Validate certificate expiry
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "ðŸ“… Checking certificate expiry..."

          # Extract certificate from keychain
          security find-certificate -a -c "Developer ID Application" -p build.keychain | \
            openssl x509 -noout -subject -dates > cert-info.txt 2>/dev/null || true

          if [[ -s cert-info.txt ]]; then
            cat cert-info.txt

            # Extract expiry date (format: notAfter=Jan 1 00:00:00 2025 GMT)
            EXPIRY_STR=$(grep "notAfter=" cert-info.txt | sed 's/notAfter=//')

            if [[ -n "$EXPIRY_STR" ]]; then
              # Convert to epoch (macOS date command)
              EXPIRY_EPOCH=$(date -j -f "%b %d %T %Y %Z" "$EXPIRY_STR" +%s 2>/dev/null || echo 0)
              NOW_EPOCH=$(date +%s)

              if [[ $EXPIRY_EPOCH -gt 0 ]]; then
                DAYS_UNTIL_EXPIRY=$(( ($EXPIRY_EPOCH - $NOW_EPOCH) / 86400 ))

                if [[ $DAYS_UNTIL_EXPIRY -lt 0 ]]; then
                  echo "::error::Certificate has expired!"
                  exit 1
                elif [[ $DAYS_UNTIL_EXPIRY -lt 30 ]]; then
                  echo "::warning::Certificate expires in $DAYS_UNTIL_EXPIRY days - please renew soon"
                elif [[ $DAYS_UNTIL_EXPIRY -lt 90 ]]; then
                  echo "::notice::Certificate expires in $DAYS_UNTIL_EXPIRY days"
                else
                  echo "âœ… Certificate is valid (expires in $DAYS_UNTIL_EXPIRY days)"
                fi
              fi
            fi
          fi

          rm -f cert-info.txt

      # ==================== BUILD ====================

      - name: Build and sign MacDown
        timeout-minutes: 30
        uses: ./.github/actions/build-macdown
        with:
          enable-signing: true
          team-id: ${{ secrets.APPLE_TEAM_ID }}

      - name: Verify code signature
        run: |
          echo "ðŸ” Verifying code signature..."
          codesign -vvv --deep --strict build/"MacDown 3000.app"
          codesign -d -r- build/"MacDown 3000.app"

          # Verify it's signed with Developer ID
          SIGNING_IDENTITY=$(codesign -dvv build/"MacDown 3000.app" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$SIGNING_IDENTITY" ]]; then
            echo "::error::App is not signed with Developer ID Application certificate"
            exit 1
          fi
          echo "âœ… Verified signature: $SIGNING_IDENTITY"

          echo "âœ… Application bundle ready"

      # ==================== CREATE DMG ====================

      - name: Create DMG installer
        run: |
          echo "ðŸ’¿ Creating DMG installer..."

          # Try create-dmg first (better UX)
          if create-dmg \
            --volname "MacDown 3000" \
            --window-pos 200 120 \
            --window-size 800 400 \
            --icon-size 100 \
            --icon "MacDown 3000.app" 200 190 \
            --hide-extension "MacDown 3000.app" \
            --app-drop-link 600 185 \
            --no-internet-enable \
            "build/MacDown-${VERSION}.dmg" \
            "build/MacDown 3000.app" 2>&1; then
            echo "âœ… DMG created with create-dmg"
          else
            echo "âš ï¸ create-dmg failed, falling back to hdiutil..."
            hdiutil create -volname "MacDown 3000" \
              -srcfolder "build/MacDown 3000.app" \
              -ov -format UDZO \
              "build/MacDown-${VERSION}.dmg"
            echo "âœ… DMG created with hdiutil"
          fi

          # Display DMG info
          ls -lh "build/MacDown-${VERSION}.dmg"
          echo "DMG size: $(du -h "build/MacDown-${VERSION}.dmg" | cut -f1)"

      - name: Verify app bundle inside DMG
        run: |
          echo "ðŸ” Verifying app bundle inside DMG..."

          # Mount the DMG
          hdiutil attach "build/MacDown-${VERSION}.dmg" -mountpoint /tmp/dmg-verify -nobrowse -readonly

          # Verify the app signature inside
          codesign -vvv --deep --strict "/tmp/dmg-verify/MacDown 3000.app"

          # Verify it's signed with Developer ID
          SIGNING_IDENTITY=$(codesign -dvv "/tmp/dmg-verify/MacDown 3000.app" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$SIGNING_IDENTITY" ]]; then
            echo "::error::App inside DMG is not properly signed"
            hdiutil detach /tmp/dmg-verify
            exit 1
          fi

          echo "âœ… App bundle inside DMG is properly signed: $SIGNING_IDENTITY"

          # Unmount
          hdiutil detach /tmp/dmg-verify

      - name: Sign DMG
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "ðŸ” Signing DMG..."

          # Get the exact signing identity to avoid ambiguity
          IDENTITY=$(security find-identity -v -p codesigning build.keychain | \
                     grep "Developer ID Application" | \
                     grep "$APPLE_TEAM_ID" | \
                     head -1 | \
                     sed -E 's/.*"(.+)"/\1/')

          if [[ -z "$IDENTITY" ]]; then
            echo "::error::Could not find Developer ID Application certificate for team $APPLE_TEAM_ID"
            security find-identity -v -p codesigning build.keychain
            exit 1
          fi

          echo "Using signing identity: $IDENTITY"

          # Sign the DMG with explicit identity
          # Note: --options runtime is NOT used for DMG files (only for executables)
          codesign --sign "$IDENTITY" \
            --timestamp \
            --force \
            "build/MacDown-${VERSION}.dmg"

          echo "âœ… DMG signed"

      - name: Verify DMG signature
        run: |
          echo "ðŸ” Verifying DMG signature..."

          # Verify the DMG signature
          codesign -vvv --deep --strict "build/MacDown-${VERSION}.dmg"

          # Show signature details
          codesign -dvv "build/MacDown-${VERSION}.dmg" 2>&1 | grep "Authority="

          # Verify it's signed with Developer ID
          SIGNING_IDENTITY=$(codesign -dvv "build/MacDown-${VERSION}.dmg" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$SIGNING_IDENTITY" ]]; then
            echo "::error::DMG is not signed with Developer ID Application certificate"
            exit 1
          fi
          echo "âœ… Verified DMG signature: $SIGNING_IDENTITY"

      - name: Generate checksums
        run: |
          echo "ðŸ” Generating SHA256 checksums..."

          cd build
          shasum -a 256 "MacDown-${VERSION}.dmg" > "MacDown-${VERSION}.dmg.sha256"

          echo "Checksum file contents:"
          cat "MacDown-${VERSION}.dmg.sha256"

          # Save checksum to environment for use in release notes
          CHECKSUM=$(cat "MacDown-${VERSION}.dmg.sha256")
          echo "CHECKSUM=$CHECKSUM" >> $GITHUB_ENV

          echo "âœ… Checksums generated"

      # ==================== NOTARIZATION ====================

      - name: Submit DMG for notarization
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "ðŸ“¤ Submitting DMG for notarization..."

          # Submit for notarization without waiting (fast, doesn't tie up runner)
          xcrun notarytool submit "build/MacDown-${VERSION}.dmg" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --no-wait \
            --output-format json > notarization-response.json

          # Extract submission ID
          SUBMISSION_ID=$(jq -r '.id' notarization-response.json)

          # Validate submission ID
          if [[ -z "$SUBMISSION_ID" ]] || [[ "$SUBMISSION_ID" == "null" ]]; then
            echo "::error::Failed to extract notarization submission ID"
            echo "Response from Apple:"
            cat notarization-response.json
            exit 1
          fi

          echo "âœ… Notarization submitted successfully"
          echo ""
          echo "ðŸ“‹ Submission ID: $SUBMISSION_ID"
          echo ""
          echo "â³ Notarization typically takes 5-15 minutes (sometimes up to 45 minutes)"
          echo "ðŸ“§ You will receive an email from Apple when complete"
          echo ""
          echo "Next steps:"
          echo "1. Wait for Apple's email confirmation"
          echo "2. Run the 'Staple and Publish Release' workflow to complete the release"

          # Save submission ID for reference
          echo "NOTARIZATION_ID=$SUBMISSION_ID" >> $GITHUB_ENV

      # ==================== CREATE RELEASE ====================

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          draft: true
          prerelease: ${{ env.PRERELEASE }}
          tag_name: ${{ github.ref_name || format('v{0}', env.VERSION) }}
          name: MacDown ${{ env.VERSION }}
          files: |
            build/MacDown-${{ env.VERSION }}.dmg
            build/MacDown-${{ env.VERSION }}.dmg.sha256
          body: |
            ## MacDown 3000 ${{ env.VERSION }}

            **Platform:** macOS (Universal - Apple Silicon and Intel)

            âš ï¸ **Notarization in progress** - This release is not yet ready for distribution.

            ### Status

            - âœ… Application bundle built and signed
            - âœ… DMG created and signed
            - â³ Submitted for Apple notarization (Submission ID: `${{ env.NOTARIZATION_ID }}`)
            - â³ Awaiting notarization approval (typically 5-15 minutes)
            - âŒ Not yet stapled

            ### Next Steps

            After receiving Apple's approval email:

            1. Go to **Actions** â†’ **Staple and Publish Release**
            2. Click **Run workflow**
            3. Enter the release tag: `${{ github.ref_name || format('v{0}', env.VERSION) }}`
            4. The workflow will:
               - Download the DMG from this release
               - Staple the notarization ticket
               - Update the DMG and checksums
               - Mark the release as ready

            Or manually staple and update:
            ```bash
            # Download DMG from this release
            # Wait for Apple email, then:
            xcrun stapler staple "MacDown-${{ env.VERSION }}.dmg"
            xcrun stapler validate "MacDown-${{ env.VERSION }}.dmg"
            # Re-upload stapled DMG to this release
            ```

            ### Verification

            **SHA256 Checksum (signed but unstapled DMG):**
            ```
            ${{ env.CHECKSUM }}
            ```

            ---

            **Build Information:**
            - Build Date: ${{ env.BUILD_TIME }}
            - Commit: ${{ github.sha }}
            - Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ==================== CLEANUP ====================

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain build.keychain 2>/dev/null || true
          echo "ðŸ§¹ Keychain cleaned up"

      - name: Upload build logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: |
            build.log
            notarization-response.json
          retention-days: 7

      - name: Upload DMG artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: dmg-unstapled
          path: build/MacDown-*.dmg*
          retention-days: 7
