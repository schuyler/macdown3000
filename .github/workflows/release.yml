name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.0, or leave empty to auto-detect from latest tag)'
        required: false

permissions:
  contents: write  # Required to create releases and upload assets

jobs:
  release:
    name: Build, Sign, Notarize, and Release
    runs-on: macos-14

    steps:
      # ==================== SETUP ====================

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0  # Need full history to check branch

      - name: Verify tag is on main branch
        if: github.ref_type == 'tag'
        run: |
          echo "ðŸ” Verifying that tag ${{ github.ref_name }} is on main branch..."

          # Get the commit hash of the tag
          TAG_COMMIT=$(git rev-parse ${{ github.ref_name }})

          # Check if this commit is reachable from main
          if git merge-base --is-ancestor "$TAG_COMMIT" origin/main 2>/dev/null; then
            echo "âœ… Tag is on main branch (or ancestor of main)"
          else
            echo "::error::Tag ${{ github.ref_name }} is NOT on the main branch!"
            echo "::error::Release tags must be created from the main branch only."
            echo "::error::Please delete this tag and create it from main:"
            echo "::error::  git push origin :refs/tags/${{ github.ref_name }}"
            echo "::error::  git tag -d ${{ github.ref_name }}"
            echo "::error::  git checkout main"
            echo "::error::  git pull origin main"
            echo "::error::  git tag ${{ github.ref_name }}"
            echo "::error::  git push origin ${{ github.ref_name }}"
            exit 1
          fi

      - name: Validate required secrets
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
        run: |
          MISSING_SECRETS=()

          if [[ -z "$APPLE_TEAM_ID" ]]; then
            MISSING_SECRETS+=("APPLE_TEAM_ID")
          fi
          if [[ -z "$APPLE_CERTIFICATE_BASE64" ]]; then
            MISSING_SECRETS+=("APPLE_CERTIFICATE_BASE64")
          fi
          if [[ -z "$APPLE_CERTIFICATE_PASSWORD" ]]; then
            MISSING_SECRETS+=("APPLE_CERTIFICATE_PASSWORD")
          fi
          if [[ -z "$APPLE_ID" ]]; then
            MISSING_SECRETS+=("APPLE_ID")
          fi
          if [[ -z "$APPLE_APP_PASSWORD" ]]; then
            MISSING_SECRETS+=("APPLE_APP_PASSWORD")
          fi

          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo "::error::Missing required GitHub secrets: ${MISSING_SECRETS[*]}"
            echo ""
            echo "Please configure the following secrets in your GitHub repository settings:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "  - $secret"
            done
            echo ""
            echo "See plans/release-process.md for setup instructions."
            exit 1
          fi

          echo "âœ… All required secrets are configured"

      - name: Extract version from tag or input
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            # Triggered by tag push
            VERSION=${GITHUB_REF#refs/tags/}
            VERSION=${VERSION#v}  # Remove 'v' prefix if present
            echo "ðŸ“Œ Using tag version: $VERSION"
          else
            # Triggered by workflow_dispatch
            PROVIDED_VERSION="${{ github.event.inputs.version }}"
            if [[ -n "$PROVIDED_VERSION" ]]; then
              VERSION="$PROVIDED_VERSION"
              echo "ðŸ“Œ Using provided version: $VERSION"
            else
              # Auto-detect latest tag
              echo "ðŸ” Auto-detecting version from latest tag..."
              LATEST_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
              if [[ -z "$LATEST_TAG" ]]; then
                echo "::error::No releases found. Please provide a version manually."
                exit 1
              fi
              VERSION=${LATEST_TAG#v}  # Remove 'v' prefix
              echo "ðŸ“Œ Auto-detected version: $VERSION"
            fi
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "ðŸ“¦ Building version: $VERSION"

      - name: Verify changelog entry exists
        run: |
          echo "ðŸ“ Checking for changelog entry for version ${VERSION}..."

          if ! grep -q "^## \[${VERSION}\]" CHANGELOG.md; then
            echo "::error::No changelog entry found for version ${VERSION}"
            echo "::error::Please add a changelog entry to CHANGELOG.md before creating a release"
            echo ""
            echo "Expected format in CHANGELOG.md:"
            echo "## [${VERSION}] - $(date -u +'%Y-%m-%d')"
            exit 1
          fi

          echo "âœ… Found changelog entry for version ${VERSION}"

      - name: Detect pre-release from version string
        run: |
          if [[ "$VERSION" =~ -(beta|alpha|rc) ]]; then
            echo "PRERELEASE=true" >> $GITHUB_ENV
            echo "ðŸ§ª Detected pre-release version"
          else
            echo "PRERELEASE=false" >> $GITHUB_ENV
            echo "ðŸš€ Detected production release version"
          fi

      - name: Set build timestamp
        run: echo "BUILD_TIME=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV

      - name: Compute build number
        run: |
          BUILD_NUMBER=$(git rev-list --count HEAD)
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "ðŸ“Œ Build number: $BUILD_NUMBER"

      # ==================== DEPENDENCIES ====================

      - name: Setup MacDown build environment
        uses: ./.github/actions/setup-macdown

      - name: Run tests before release
        run: |
          echo "ðŸ§ª Running unit tests to ensure code quality before release..."
          set -o pipefail
          xcodebuild test \
            -workspace "MacDown 3000.xcworkspace" \
            -scheme MacDown \
            -derivedDataPath DerivedData \
            | xcpretty --color
          echo "âœ… All tests passed"

      - name: Install build tools
        run: brew install create-dmg jq

      # ==================== CODE SIGNING SETUP ====================

      - name: Setup code signing keychain
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          echo "ðŸ” Setting up code signing keychain..."

          # Generate random password for temporary keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

          # Import Developer ID certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > certificate.p12

          # Use trap to ensure certificate cleanup even on error
          trap 'rm -f certificate.p12' EXIT

          security import certificate.p12 \
            -k build.keychain \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign

          # Prevent codesign from prompting for keychain password
          security set-key-partition-list \
            -S apple-tool:,apple: \
            -s \
            -k "$KEYCHAIN_PASSWORD" \
            build.keychain

          # Verify certificate is available
          echo "ðŸ“‹ Available code signing identities:"
          security find-identity -v -p codesigning

      - name: Validate certificate expiry
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "ðŸ“… Checking certificate expiry..."

          # Extract certificate from keychain
          security find-certificate -a -c "Developer ID Application" -p build.keychain | \
            openssl x509 -noout -subject -dates > cert-info.txt 2>/dev/null || true

          if [[ -s cert-info.txt ]]; then
            cat cert-info.txt

            # Extract expiry date (format: notAfter=Jan 1 00:00:00 2025 GMT)
            EXPIRY_STR=$(grep "notAfter=" cert-info.txt | sed 's/notAfter=//')

            if [[ -n "$EXPIRY_STR" ]]; then
              # Convert to epoch (macOS date command)
              EXPIRY_EPOCH=$(date -j -f "%b %d %T %Y %Z" "$EXPIRY_STR" +%s 2>/dev/null || echo 0)
              NOW_EPOCH=$(date +%s)

              if [[ $EXPIRY_EPOCH -gt 0 ]]; then
                DAYS_UNTIL_EXPIRY=$(( ($EXPIRY_EPOCH - $NOW_EPOCH) / 86400 ))

                if [[ $DAYS_UNTIL_EXPIRY -lt 0 ]]; then
                  echo "::error::Certificate has expired!"
                  exit 1
                elif [[ $DAYS_UNTIL_EXPIRY -lt 30 ]]; then
                  echo "::warning::Certificate expires in $DAYS_UNTIL_EXPIRY days - please renew soon"
                elif [[ $DAYS_UNTIL_EXPIRY -lt 90 ]]; then
                  echo "::notice::Certificate expires in $DAYS_UNTIL_EXPIRY days"
                else
                  echo "âœ… Certificate is valid (expires in $DAYS_UNTIL_EXPIRY days)"
                fi
              fi
            fi
          fi

          rm -f cert-info.txt

      # ==================== BUILD ====================

      - name: Build and sign MacDown
        timeout-minutes: 30
        uses: ./.github/actions/build-macdown
        with:
          enable-signing: true
          team-id: ${{ secrets.APPLE_TEAM_ID }}
          marketing-version: ${{ env.VERSION }}
          build-number: ${{ env.BUILD_NUMBER }}

      - name: Sign CLI binary explicitly
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "ðŸ” Signing macdown CLI binary..."

          CLI_BINARY="build/MacDown 3000.app/Contents/SharedSupport/bin/macdown"

          # Verify CLI binary exists
          if [ ! -f "$CLI_BINARY" ]; then
            echo "::error::CLI binary not found at expected location: $CLI_BINARY"
            exit 1
          fi

          # Get the exact signing identity (same as DMG signing)
          IDENTITY=$(security find-identity -v -p codesigning build.keychain | \
                     grep "Developer ID Application" | \
                     grep "$APPLE_TEAM_ID" | \
                     head -1 | \
                     sed -E 's/.*"(.+)"/\1/')

          if [[ -z "$IDENTITY" ]]; then
            echo "::error::Could not find Developer ID Application certificate"
            exit 1
          fi

          echo "Using signing identity: $IDENTITY"

          # Sign the CLI binary with full signing options
          # --force: Replace existing signature from CodeSignOnCopy
          # --options runtime: Enable hardened runtime (required for notarization)
          # --timestamp: Add secure timestamp from Apple's servers
          codesign --sign "$IDENTITY" \
            --force \
            --options runtime \
            --timestamp \
            "$CLI_BINARY"

          echo "âœ… CLI binary signed successfully"

          # Re-sign the app bundle to update the seal after modifying nested component
          echo "ðŸ” Re-signing app bundle to update code signature seal..."
          codesign --sign "$IDENTITY" \
            --force \
            --deep \
            --options runtime \
            --timestamp \
            "build/MacDown 3000.app"

          echo "âœ… App bundle re-signed successfully"

      - name: Verify code signature
        run: |
          echo "ðŸ” Verifying code signature..."
          codesign -vvv --deep --strict build/"MacDown 3000.app"
          codesign -d -r- build/"MacDown 3000.app"

          # Verify it's signed with Developer ID
          SIGNING_IDENTITY=$(codesign -dvv build/"MacDown 3000.app" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$SIGNING_IDENTITY" ]]; then
            echo "::error::App is not signed with Developer ID Application certificate"
            exit 1
          fi
          echo "âœ… Verified signature: $SIGNING_IDENTITY"

          # Verify CLI binary signature explicitly
          echo "ðŸ” Verifying CLI binary signature..."
          CLI_BINARY="build/MacDown 3000.app/Contents/SharedSupport/bin/macdown"

          codesign -vvv --strict "$CLI_BINARY"

          # Verify CLI binary is signed with Developer ID
          CLI_SIGNING_IDENTITY=$(codesign -dvv "$CLI_BINARY" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$CLI_SIGNING_IDENTITY" ]]; then
            echo "::error::CLI binary is not signed with Developer ID Application certificate"
            exit 1
          fi
          echo "âœ… Verified CLI binary signature: $CLI_SIGNING_IDENTITY"

          # Verify CLI binary has hardened runtime
          CLI_FLAGS=$(codesign -dvv "$CLI_BINARY" 2>&1 | grep "flags=" || true)
          if [[ "$CLI_FLAGS" != *"runtime"* ]]; then
            echo "::error::CLI binary does not have hardened runtime enabled"
            echo "Flags found: $CLI_FLAGS"
            exit 1
          fi
          echo "âœ… CLI binary has hardened runtime enabled"

          # Show CLI binary signature details
          echo "ðŸ“‹ CLI binary signature details:"
          codesign -dvv "$CLI_BINARY" 2>&1 | head -20

          echo "âœ… Application bundle ready"

      # ==================== CREATE DMG ====================

      - name: Create DMG installer
        run: |
          echo "ðŸ’¿ Creating DMG installer..."

          # Try create-dmg first (better UX)
          if create-dmg \
            --volname "MacDown 3000" \
            --window-pos 200 120 \
            --window-size 800 400 \
            --icon-size 100 \
            --icon "MacDown 3000.app" 200 190 \
            --hide-extension "MacDown 3000.app" \
            --app-drop-link 600 185 \
            --no-internet-enable \
            "build/MacDown-${VERSION}.dmg" \
            "build/MacDown 3000.app" 2>&1; then
            echo "âœ… DMG created with create-dmg"
          else
            echo "âš ï¸ create-dmg failed, falling back to hdiutil..."
            hdiutil create -volname "MacDown 3000" \
              -srcfolder "build/MacDown 3000.app" \
              -ov -format UDZO \
              "build/MacDown-${VERSION}.dmg"
            echo "âœ… DMG created with hdiutil"
          fi

          # Display DMG info
          ls -lh "build/MacDown-${VERSION}.dmg"
          echo "DMG size: $(du -h "build/MacDown-${VERSION}.dmg" | cut -f1)"

      - name: Verify app bundle inside DMG
        run: |
          echo "ðŸ” Verifying app bundle inside DMG..."

          # Mount the DMG
          hdiutil attach "build/MacDown-${VERSION}.dmg" -mountpoint /tmp/dmg-verify -nobrowse -readonly

          # Verify the app signature inside
          codesign -vvv --deep --strict "/tmp/dmg-verify/MacDown 3000.app"

          # Verify it's signed with Developer ID
          SIGNING_IDENTITY=$(codesign -dvv "/tmp/dmg-verify/MacDown 3000.app" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$SIGNING_IDENTITY" ]]; then
            echo "::error::App inside DMG is not properly signed"
            hdiutil detach /tmp/dmg-verify
            exit 1
          fi

          echo "âœ… App bundle inside DMG is properly signed: $SIGNING_IDENTITY"

          # Verify CLI binary inside DMG
          echo "ðŸ” Verifying CLI binary inside DMG..."
          CLI_BINARY_IN_DMG="/tmp/dmg-verify/MacDown 3000.app/Contents/SharedSupport/bin/macdown"

          if [ ! -f "$CLI_BINARY_IN_DMG" ]; then
            echo "::error::CLI binary not found in DMG"
            hdiutil detach /tmp/dmg-verify
            exit 1
          fi

          codesign -vvv --strict "$CLI_BINARY_IN_DMG"

          CLI_IN_DMG_IDENTITY=$(codesign -dvv "$CLI_BINARY_IN_DMG" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$CLI_IN_DMG_IDENTITY" ]]; then
            echo "::error::CLI binary in DMG is not properly signed"
            hdiutil detach /tmp/dmg-verify
            exit 1
          fi

          # Verify CLI binary in DMG has hardened runtime
          CLI_DMG_FLAGS=$(codesign -dvv "$CLI_BINARY_IN_DMG" 2>&1 | grep "flags=" || true)
          if [[ "$CLI_DMG_FLAGS" != *"runtime"* ]]; then
            echo "::error::CLI binary in DMG does not have hardened runtime enabled"
            hdiutil detach /tmp/dmg-verify
            exit 1
          fi

          echo "âœ… CLI binary inside DMG is properly signed: $CLI_IN_DMG_IDENTITY"
          echo "âœ… CLI binary in DMG has hardened runtime enabled"

          # Unmount
          hdiutil detach /tmp/dmg-verify

      - name: Sign DMG
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "ðŸ” Signing DMG..."

          # Get the exact signing identity to avoid ambiguity
          IDENTITY=$(security find-identity -v -p codesigning build.keychain | \
                     grep "Developer ID Application" | \
                     grep "$APPLE_TEAM_ID" | \
                     head -1 | \
                     sed -E 's/.*"(.+)"/\1/')

          if [[ -z "$IDENTITY" ]]; then
            echo "::error::Could not find Developer ID Application certificate for team $APPLE_TEAM_ID"
            security find-identity -v -p codesigning build.keychain
            exit 1
          fi

          echo "Using signing identity: $IDENTITY"

          # Sign the DMG with explicit identity
          # Note: --options runtime is NOT used for DMG files (only for executables)
          codesign --sign "$IDENTITY" \
            --timestamp \
            --force \
            "build/MacDown-${VERSION}.dmg"

          echo "âœ… DMG signed"

      - name: Verify DMG signature
        run: |
          echo "ðŸ” Verifying DMG signature..."

          # Verify the DMG signature
          codesign -vvv --deep --strict "build/MacDown-${VERSION}.dmg"

          # Show signature details
          codesign -dvv "build/MacDown-${VERSION}.dmg" 2>&1 | grep "Authority="

          # Verify it's signed with Developer ID
          SIGNING_IDENTITY=$(codesign -dvv "build/MacDown-${VERSION}.dmg" 2>&1 | grep "Authority=Developer ID Application")
          if [[ -z "$SIGNING_IDENTITY" ]]; then
            echo "::error::DMG is not signed with Developer ID Application certificate"
            exit 1
          fi
          echo "âœ… Verified DMG signature: $SIGNING_IDENTITY"

      - name: Generate checksums
        run: |
          echo "ðŸ” Generating SHA256 checksums..."

          cd build
          shasum -a 256 "MacDown-${VERSION}.dmg" > "MacDown-${VERSION}.dmg.sha256"

          echo "Checksum file contents:"
          cat "MacDown-${VERSION}.dmg.sha256"

          # Save checksum to environment for use in release notes
          CHECKSUM=$(cat "MacDown-${VERSION}.dmg.sha256")
          echo "CHECKSUM=$CHECKSUM" >> $GITHUB_ENV

          echo "âœ… Checksums generated"

      # ==================== NOTARIZATION ====================

      - name: Submit DMG for notarization
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "ðŸ“¤ Submitting DMG for notarization..."

          # Submit for notarization without waiting (fast, doesn't tie up runner)
          xcrun notarytool submit "build/MacDown-${VERSION}.dmg" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --no-wait \
            --output-format json > notarization-response.json

          # Extract submission ID
          SUBMISSION_ID=$(jq -r '.id' notarization-response.json)

          # Validate submission ID
          if [[ -z "$SUBMISSION_ID" ]] || [[ "$SUBMISSION_ID" == "null" ]]; then
            echo "::error::Failed to extract notarization submission ID"
            echo "Response from Apple:"
            cat notarization-response.json
            exit 1
          fi

          echo "âœ… Notarization submitted successfully"
          echo ""
          echo "ðŸ“‹ Submission ID: $SUBMISSION_ID"
          echo ""
          echo "â³ Notarization typically takes 5-15 minutes (sometimes up to 45 minutes)"
          echo "ðŸ“§ You will receive an email from Apple when complete"
          echo ""
          echo "Next steps:"
          echo "1. Wait for Apple's email confirmation"
          echo "2. Run the 'Staple and Publish Release' workflow to complete the release"

          # Save submission ID for reference
          echo "NOTARIZATION_ID=$SUBMISSION_ID" >> $GITHUB_ENV

      # ==================== CREATE RELEASE ====================

      - name: Generate release notes
        run: |
          echo "ðŸ“ Generating release notes from CHANGELOG.md..."

          # Extract changelog for this version using string matching (not regex)
          CHANGELOG_CONTENT=$(awk -v ver="${VERSION}" '
            /^## \[/ {
              if (found) exit
              if (index($0, "[" ver "]") > 0) {
                found=1
                next
              }
            }
            found && /^## / { exit }
            found && !/^---$/ { print }
          ' CHANGELOG.md)

          if [ -z "$CHANGELOG_CONTENT" ]; then
            echo "::error::Failed to extract changelog content for version ${VERSION}"
            exit 1
          fi

          echo "âœ… Extracted changelog for version ${VERSION}"

          # Create release notes with changelog + notarization status
          cat > build/release-notes.md <<EOF
          **MacDown 3000** is a modern, open-source Markdown editor for macOS.

          ${CHANGELOG_CONTENT}

          ---

          ## Release Status

          âš ï¸ **Notarization in progress** - This release is not yet ready for distribution.

          ### Current Status

          - âœ… Application bundle built and signed
          - âœ… DMG created and signed
          - â³ Submitted for Apple notarization (typically takes 5-15 minutes)
          - âŒ Not yet stapled

          **Notarization Details:**
          - Submission ID: \`${NOTARIZATION_ID}\`

          ### Next Steps

          After receiving Apple's notarization approval email:

          1. Go to **Actions** â†’ **Staple and Publish Release**
          2. Click **Run workflow**
          3. Enter the release tag: \`${TAG_NAME}\`

          The workflow will automatically:
          - Staple the notarization ticket to the DMG
          - Update the release with the stapled DMG
          - Update these release notes with installation instructions

          ### Verification (Unstapled DMG)

          **SHA256 Checksum:**
          \`\`\`
          ${CHECKSUM}
          \`\`\`

          **Build Information:**
          - Build Date: ${BUILD_TIME}
          - Commit: ${GITHUB_SHA}
          - Workflow: ${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}
          EOF

          echo "âœ… Release notes generated"
        env:
          TAG_NAME: ${{ github.ref_type == 'tag' && github.ref_name || format('v{0}', env.VERSION) }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          draft: true
          prerelease: ${{ env.PRERELEASE }}
          tag_name: ${{ github.ref_type == 'tag' && github.ref_name || format('v{0}', env.VERSION) }}
          name: MacDown ${{ env.VERSION }}
          files: |
            build/MacDown-${{ env.VERSION }}.dmg
            build/MacDown-${{ env.VERSION }}.dmg.sha256
          body_path: build/release-notes.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ==================== CLEANUP ====================

      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain build.keychain 2>/dev/null || true
          echo "ðŸ§¹ Keychain cleaned up"

      - name: Upload build logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs
          path: |
            build.log
            notarization-response.json
          retention-days: 7

      - name: Upload DMG artifact
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: dmg-unstapled
          path: build/MacDown-*.dmg*
          retention-days: 7
